rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Allow public read access to the visitor count, but prevent client-side writes.
    // Writes should only be handled by the backend server.
    match /visitors/{visitorId} {
      allow read: if true;
      allow write: if false;
    }
    
    // User profiles collection rules
    match /userProfiles/{userId} {
      // Users can read their own profile, and public profiles can be read by anyone
      allow read: if request.auth != null && (
                    request.auth.uid == userId  // Own profile
                    || resource.data.isPublic == true  // Public profile
                  );
      
      // Users can create their own profile with proper validation
      allow create: if request.auth != null 
                   && request.auth.uid == userId
                   && isValidUserProfile(request.resource.data);
      
      // Users can update their own profile
      allow update: if request.auth != null 
                   && request.auth.uid == userId
                   && isValidUserProfileUpdate(request.resource.data, resource.data);
      
      // Users can delete their own profile, or admin can delete any profile
      allow delete: if request.auth != null && (
                     request.auth.uid == userId  // Own profile
                     || hasAdminRole(request.auth)  // Admin deletion
                   );
      
      // User preferences subcollection
      match /preferences/{preferenceId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // User activity/analytics subcollection
      match /activity/{activityId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // Comments collection rules with enhanced functionality
    match /comments/{commentId} {
      // Allow anyone to read comments for public access
      // Note: parentId field handling - undefined vs null requires special handling
      allow read: if true;
      
      // Allow creation of new comments and replies with proper validation
      allow create: if isValidComment(request.resource.data)
                   && (
                     // Authenticated users
                     (request.auth != null && request.auth.uid == request.resource.data.authorId)
                     // Or server-side creation (when using Firebase Admin SDK) for anonymous/guest IDs
                     || (request.auth == null && isAnonymousOrGuest(request.resource.data.authorId))
                   );
      
      // Enhanced update rules for editing, liking, and system updates
      allow update: if (
                     // Server-side update (Firebase Admin SDK) - no auth required
                     request.auth == null
                     // User editing their own comment content
                     || (request.auth != null 
                         && request.auth.uid == resource.data.authorId
                         && isValidCommentEdit(request.resource.data, resource.data))
                     // User updating vote counts (like/unlike functionality)
                     || (request.auth != null && isVoteCountUpdate(request.resource.data, resource.data))
                     // Moderator/admin updates (e.g., marking as reported)
                     || (request.auth != null && hasModeratorRole(request.auth) 
                         && isValidModerationUpdate(request.resource.data, resource.data))
                   );
      
      // Enhanced deletion rules - users can delete their own content, moderators can delete any
      allow delete: if (
                     // Server-side deletion (Firebase Admin SDK)
                     request.auth == null
                     // User deleting their own comment
                     || (request.auth != null && request.auth.uid == resource.data.authorId)
                     // Admin/moderator deletion
                     || (request.auth != null && hasModeratorRole(request.auth))
                   );
      
      // Enhanced votes subcollection for like/unlike functionality
      match /votes/{userId} {
        // Allow authenticated users to manage their own votes (like/unlike)
        allow create, update, delete: if request.auth != null 
                                      && request.auth.uid == userId 
                                      && isValidVote(request.resource.data);
        
        // Allow reading all votes for vote counting and display
        allow read: if true;
        
        // Allow server-side access (Firebase Admin SDK)
        allow read, write: if request.auth == null;
      }
      
      // Replies subcollection for nested comments
      match /replies/{replyId} {
        // Allow reading all replies
        allow read: if true;
        
        // Allow creating replies with proper validation
        allow create: if isValidReply(request.resource.data)
                     && (
                       // Authenticated users
                       (request.auth != null && request.auth.uid == request.resource.data.authorId)
                       // Or server-side creation for anonymous/guest users
                       || (request.auth == null && isAnonymousOrGuest(request.resource.data.authorId))
                     );
        
        // Allow updating replies (editing)
        allow update: if (
                       // Server-side update
                       request.auth == null
                       // User editing their own reply
                       || (request.auth != null 
                           && request.auth.uid == resource.data.authorId
                           && isValidReplyEdit(request.resource.data, resource.data))
                       // Vote count updates for replies
                       || (request.auth != null && isVoteCountUpdate(request.resource.data, resource.data))
                       // Moderator updates
                       || (request.auth != null && hasModeratorRole(request.auth))
                     );
        
        // Allow deleting replies
        allow delete: if (
                       // Server-side deletion
                       request.auth == null
                       // User deleting their own reply
                       || (request.auth != null && request.auth.uid == resource.data.authorId)
                       // Admin/moderator deletion
                       || (request.auth != null && hasModeratorRole(request.auth))
                     );
        
        // Reply votes subcollection
        match /votes/{userId} {
          allow create, update, delete: if request.auth != null 
                                        && request.auth.uid == userId 
                                        && isValidVote(request.resource.data);
          allow read: if true;
          allow read, write: if request.auth == null;
        }
      }
    }
    
    // Reports collection for content reporting
    match /reports/{reportId} {
      // Only moderators and admins can read reports
      allow read: if request.auth != null && hasModeratorRole(request.auth);
      
      // Allow authenticated users to create reports
      allow create: if request.auth != null 
                   && isValidReport(request.resource.data)
                   && request.auth.uid == request.resource.data.reporterId;
      
      // Only moderators can update reports (e.g., mark as resolved)
      allow update: if request.auth != null && hasModeratorRole(request.auth);
      
      // Only admins can delete reports
      allow delete: if request.auth != null && hasAdminRole(request.auth);
      
      // Server-side access
      allow read, write: if request.auth == null;
    }
    
    // User reactions/likes collection (alternative approach)
    match /reactions/{reactionId} {
      // Allow reading reactions for displaying like counts
      allow read: if true;
      
      // Allow users to create their own reactions
      allow create: if request.auth != null 
                   && isValidReaction(request.resource.data)
                   && request.auth.uid == request.resource.data.userId;
      
      // Allow users to update/delete their own reactions
      allow update, delete: if request.auth != null 
                           && request.auth.uid == resource.data.userId;
      
      // Server-side access
      allow read, write: if request.auth == null;
    }
    
    // Metadata collection for counters and app-level docs
    match /metadata/{docId} {
      // Allow authenticated clients to read and update only the userCounter doc
      allow read: if request.auth != null && docId == 'userCounter';
      allow create, update: if request.auth != null && docId == 'userCounter' && isValidUserCounterUpdate(request.resource.data, resource.data);
      // Disallow deletes from clients
      allow delete: if false;
    }
    
    // Helper functions
    function isValidComment(data) {
      return data.keys().hasAll(['content', 'authorId', 'authorName', 'pageId', 'createdAt', 'upvotes', 'downvotes', 'authorIsVerified', 'authorIsAnonymous', 'authorIsGuest', 'isEdited'])
             && data.content is string
             && data.content.size() > 0
             && data.content.size() <= 2000  // Max 2000 characters
             && data.authorId is string
             && data.authorName is string
             && data.pageId is string
             && data.createdAt is timestamp
             && data.upvotes is number
             && data.downvotes is number
             && data.upvotes >= 0
             && data.downvotes >= 0
             && data.authorIsVerified is bool
             && data.authorIsAnonymous is bool
             && data.authorIsGuest is bool
             && data.isEdited is bool
             // Optional fields validation
             && (!('parentId' in data) || data.parentId is string)
             && (!('authorAvatar' in data) || data.authorAvatar is string)
             && (!('updatedAt' in data) || data.updatedAt is timestamp);
    }
    
    function isAnonymousOrGuest(authorId) {
      // Check if the authorId follows the pattern for anonymous or guest users
      return authorId.matches('anon_[0-9]+_[a-zA-Z0-9]+') 
             || authorId.matches('guest_[0-9]+_[a-zA-Z0-9]+');
    }
    
    function isValidVote(data) {
      return data.keys().hasAll(['userId', 'type', 'createdAt'])
             && data.userId is string
             && data.type in ['upvote', 'downvote']
             && data.createdAt is timestamp;
    }
    
    function isVoteCountUpdate(newData, oldData) {
      // Allow updates that only change upvotes and downvotes (for voting functionality)
      return (
        // All required fields must be present and unchanged except vote counts
        newData.content == oldData.content
        && newData.authorId == oldData.authorId
        && newData.authorName == oldData.authorName
        && newData.pageId == oldData.pageId
        && newData.createdAt == oldData.createdAt
        && newData.authorIsVerified == oldData.authorIsVerified
        && newData.authorIsAnonymous == oldData.authorIsAnonymous
        && newData.authorIsGuest == oldData.authorIsGuest
        && newData.isEdited == oldData.isEdited
        // Vote counts can change (this is what we're updating)
        && newData.upvotes is number
        && newData.downvotes is number
        && newData.upvotes >= 0
        && newData.downvotes >= 0
        // Optional fields should remain the same if they exist
        && (!('parentId' in oldData) || newData.parentId == oldData.parentId)
        && (!('authorAvatar' in oldData) || newData.authorAvatar == oldData.authorAvatar)
        && (!('updatedAt' in oldData) || newData.updatedAt == oldData.updatedAt)
      );
    }
    
    function hasAdminRole(auth) {
      return auth.token.admin == true;
    }
    
    function hasModeratorRole(auth) {
      return auth.token.admin == true || auth.token.moderator == true;
    }
    
    function isValidCommentEdit(newData, oldData) {
      // Allow editing content, updatedAt, and isEdited fields
      return newData.content is string
             && newData.content.size() > 0
             && newData.content.size() <= 2000
             && newData.isEdited == true
             && newData.updatedAt is timestamp
             // Ensure critical fields haven't changed
             && newData.authorId == oldData.authorId
             && newData.authorName == oldData.authorName
             && newData.pageId == oldData.pageId
             && newData.createdAt == oldData.createdAt
             && newData.upvotes == oldData.upvotes
             && newData.downvotes == oldData.downvotes;
    }
    
    function isValidModerationUpdate(newData, oldData) {
      // Allow moderators to update moderation fields
      return (
        // Core content should remain unchanged
        newData.content == oldData.content
        && newData.authorId == oldData.authorId
        && newData.authorName == oldData.authorName
        && newData.pageId == oldData.pageId
        && newData.createdAt == oldData.createdAt
        // Allow moderation fields to be updated
        && (!('isReported' in newData) || newData.isReported is bool)
        && (!('isFlagged' in newData) || newData.isFlagged is bool)
        && (!('isHidden' in newData) || newData.isHidden is bool)
        && (!('moderationReason' in newData) || newData.moderationReason is string)
      );
    }
    
    function isValidReply(data) {
      return data.keys().hasAll(['content', 'authorId', 'authorName', 'parentId', 'createdAt', 'upvotes', 'downvotes', 'authorIsVerified', 'authorIsAnonymous', 'authorIsGuest', 'isEdited'])
             && data.content is string
             && data.content.size() > 0
             && data.content.size() <= 2000  // Max 2000 characters
             && data.authorId is string
             && data.authorName is string
             && data.parentId is string  // Required for replies
             && data.createdAt is timestamp
             && data.upvotes is number
             && data.downvotes is number
             && data.upvotes >= 0
             && data.downvotes >= 0
             && data.authorIsVerified is bool
             && data.authorIsAnonymous is bool
             && data.authorIsGuest is bool
             && data.isEdited is bool
             // Optional fields validation
             && (!('authorAvatar' in data) || data.authorAvatar is string)
             && (!('updatedAt' in data) || data.updatedAt is timestamp);
    }
    
    function isValidReplyEdit(newData, oldData) {
      // Allow editing reply content, updatedAt, and isEdited fields
      return newData.content is string
             && newData.content.size() > 0
             && newData.content.size() <= 2000
             && newData.isEdited == true
             && newData.updatedAt is timestamp
             // Ensure critical fields haven't changed
             && newData.authorId == oldData.authorId
             && newData.authorName == oldData.authorName
             && newData.parentId == oldData.parentId
             && newData.createdAt == oldData.createdAt
             && newData.upvotes == oldData.upvotes
             && newData.downvotes == oldData.downvotes;
    }
    
    function isValidReport(data) {
      return data.keys().hasAll(['reporterId', 'reporterName', 'contentId', 'contentType', 'reason', 'description', 'createdAt', 'status'])
             && data.reporterId is string
             && data.reporterName is string
             && data.contentId is string  // ID of the reported comment/reply
             && data.contentType in ['comment', 'reply']  // Type of content being reported
             && data.reason in ['spam', 'harassment', 'inappropriate', 'hate_speech', 'misinformation', 'other']
             && data.description is string
             && data.description.size() <= 1000  // Max 1000 characters for description
             && data.createdAt is timestamp
             && data.status in ['pending', 'reviewed', 'resolved', 'dismissed']
             // Optional fields
             && (!('contentAuthorId' in data) || data.contentAuthorId is string)
             && (!('resolvedAt' in data) || data.resolvedAt is timestamp)
             && (!('resolvedBy' in data) || data.resolvedBy is string);
    }
    
    function isValidReaction(data) {
      return data.keys().hasAll(['userId', 'userName', 'contentId', 'contentType', 'reactionType', 'createdAt'])
             && data.userId is string
             && data.userName is string
             && data.contentId is string  // ID of the liked comment/reply
             && data.contentType in ['comment', 'reply']  // Type of content being liked
             && data.reactionType in ['like', 'love', 'laugh', 'angry', 'sad']  // Different reaction types
             && data.createdAt is timestamp
             // Optional fields
             && (!('updatedAt' in data) || data.updatedAt is timestamp);
    }
    
    function isValidUserProfile(data) {
      return data.keys().hasAll(['uid', 'email', 'displayName', 'createdAt', 'lastLoginAt', 'isPublic'])
             && data.uid is string
             && data.email is string
             && data.displayName is string
             && data.displayName.size() > 0
             && data.displayName.size() <= 100  // Max 100 characters
             && data.createdAt is timestamp
             && data.lastLoginAt is timestamp
             && data.isPublic is bool
             // Optional fields validation
             && (!('profilePicture' in data) || data.profilePicture is string)
             && (!('bio' in data) || (data.bio is string && data.bio.size() <= 500))  // Max 500 characters
             && (!('location' in data) || (data.location is string && data.location.size() <= 100))
             && (!('website' in data) || (data.website is string && data.website.size() <= 200))
             && (!('updatedAt' in data) || data.updatedAt is timestamp)
             && (!('loginCount' in data) || data.loginCount is number)
             && (!('isEmailVerified' in data) || data.isEmailVerified is bool)
             && (!('provider' in data) || data.provider is string)
             && (!('role' in data) || data.role in ['user', 'moderator', 'admin'])
             && (!('status' in data) || data.status in ['active', 'inactive', 'suspended']);
    }
    
    function isValidUserProfileUpdate(newData, oldData) {
      return (
        // Immutable fields that cannot be changed after creation
        newData.uid == oldData.uid
        && newData.email == oldData.email
        && newData.createdAt == oldData.createdAt
        // Updatable fields with validation
        && newData.displayName is string
        && newData.displayName.size() > 0
        && newData.displayName.size() <= 100
        && newData.isPublic is bool
        && newData.lastLoginAt is timestamp
        && newData.updatedAt is timestamp
        // Optional fields validation
        && (!('profilePicture' in newData) || newData.profilePicture is string)
        && (!('bio' in newData) || (newData.bio is string && newData.bio.size() <= 500))
        && (!('location' in newData) || (newData.location is string && newData.location.size() <= 100))
        && (!('website' in newData) || (newData.website is string && newData.website.size() <= 200))
        && (!('loginCount' in newData) || newData.loginCount is number)
        && (!('isEmailVerified' in newData) || newData.isEmailVerified is bool)
        && (!('provider' in newData) || newData.provider is string)
        && (!('role' in newData) || newData.role in ['user', 'moderator', 'admin'])
        && (!('status' in newData) || newData.status in ['active', 'inactive', 'suspended'])
      );
    }
    function isValidUserCounterUpdate(newData, oldData) {
      // Allow creating/updating a simple counter doc with lastUserId and updatedAt only
      return newData.keys().hasOnly(['lastUserId', 'updatedAt'])
             && newData.lastUserId is number
             && newData.lastUserId >= (resource == null ? 0 : oldData.lastUserId)
             && newData.updatedAt is timestamp;
    }
  }
}
