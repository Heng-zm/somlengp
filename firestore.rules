rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Allow public read access to the visitor count, but prevent client-side writes.
    // Writes should only be handled by the backend server.
    match /visitors/{visitorId} {
      allow read: if true;
      allow write: if false;
    }
    
    // Comments collection rules
    match /comments/{commentId} {
      // Allow anyone to read comments for public access
      allow read: if true;
      
      // Allow creation of new comments with proper validation
      allow create: if isValidComment(request.resource.data)
                   && (
                     // Authenticated users
                     (request.auth != null && request.auth.uid == request.resource.data.authorId)
                     // Or server-side creation (when using Firebase Admin SDK) for anonymous/guest IDs
                     || (request.auth == null && isAnonymousOrGuest(request.resource.data.authorId))
                   );
      
      // Allow updates - server-side or by authenticated users
      allow update: if (
                     // Server-side update (Firebase Admin SDK)
                     request.auth == null
                     // Or authenticated user updating their own comment
                     || (request.auth != null 
                         && request.auth.uid == resource.data.authorId
                         && isValidCommentUpdate(request.resource.data, resource.data))
                   );
      
      // Allow deletion - server-side or by authenticated users/admins
      allow delete: if (
                     // Server-side deletion (Firebase Admin SDK)
                     request.auth == null
                     // Or authenticated user/admin
                     || (request.auth != null && 
                         (request.auth.uid == resource.data.authorId || 
                          hasAdminRole(request.auth)))
                   );
      
      // Comment votes subcollection
      match /votes/{userId} {
        // Allow server-side access or user's own votes
        allow read, write: if request.auth == null || 
                             (request.auth != null && request.auth.uid == userId);
        
        // Allow reading votes for vote counting
        allow read: if true;
      }
    }
    
    // Helper functions
    function isValidComment(data) {
      return data.keys().hasAll(['content', 'authorId', 'authorName', 'pageId', 'createdAt', 'upvotes', 'downvotes', 'authorIsVerified', 'authorIsAnonymous', 'authorIsGuest', 'isEdited'])
             && data.content is string
             && data.content.size() > 0
             && data.content.size() <= 2000  // Max 2000 characters
             && data.authorId is string
             && data.authorName is string
             && data.pageId is string
             && data.createdAt is timestamp
             && data.upvotes is number
             && data.downvotes is number
             && data.upvotes >= 0
             && data.downvotes >= 0
             && data.authorIsVerified is bool
             && data.authorIsAnonymous is bool
             && data.authorIsGuest is bool
             && data.isEdited is bool
             // Optional fields validation
             && (!('parentId' in data) || data.parentId is string)
             && (!('authorAvatar' in data) || data.authorAvatar is string)
             && (!('updatedAt' in data) || data.updatedAt is timestamp);
    }
    
    function isValidCommentUpdate(newData, oldData) {
      // Only allow updating content, updatedAt, and isEdited fields
      return newData.keys().hasAll(['content', 'updatedAt', 'isEdited'])
             && newData.content is string
             && newData.content.size() > 0
             && newData.content.size() <= 2000
             && newData.isEdited == true
             && newData.updatedAt is timestamp
             // Ensure critical fields haven't changed
             && newData.authorId == oldData.authorId
             && newData.authorName == oldData.authorName
             && newData.pageId == oldData.pageId
             && newData.createdAt == oldData.createdAt;
    }
    
    function isAnonymousOrGuest(authorId) {
      // Check if the authorId follows the pattern for anonymous or guest users
      return authorId.matches('anon_[0-9]+_[a-zA-Z0-9]+') 
             || authorId.matches('guest_[0-9]+_[a-zA-Z0-9]+');
    }
    
    function isValidVote(data) {
      return data.keys().hasAll(['userId', 'type', 'createdAt'])
             && data.userId is string
             && data.type in ['upvote', 'downvote']
             && data.createdAt is timestamp;
    }
    
    function hasAdminRole(auth) {
      return auth.token.admin == true;
    }
  }
}
