{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/client-export.ts"],"sourcesContent":["\n'use client';\n\nimport { Document, Packer, Paragraph, TextRun } from \"docx\";\nimport type { TranscriptWord } from \"./types\";\n\nfunction formatSrtTime(totalSeconds: number): string {\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = Math.floor(totalSeconds % 60);\n    const milliseconds = Math.round((totalSeconds - Math.floor(totalSeconds)) * 1000);\n  \n    const pad = (num: number) => num.toString().padStart(2, '0');\n    const padMs = (num: number) => num.toString().padStart(3, '0');\n  \n    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)},${padMs(milliseconds)}`;\n}\n\nfunction formatVttTime(totalSeconds: number): string {\n    const hours = Math.floor(totalSeconds / 3600);\n    const minutes = Math.floor((totalSeconds % 3600) / 60);\n    const seconds = Math.floor(totalSeconds % 60);\n    const milliseconds = Math.round((totalSeconds - Math.floor(totalSeconds)) * 1000);\n  \n    const pad = (num: number) => num.toString().padStart(2, '0');\n    const padMs = (num: number) => num.toString().padStart(3, '0');\n  \n    if (hours > 0) {\n        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}.${padMs(milliseconds)}`;\n    }\n    return `${pad(minutes)}:${pad(seconds)}.${padMs(milliseconds)}`;\n}\n\nfunction groupWordsIntoSegments(words: TranscriptWord[], segmentDuration: number): { text: string; start: number; end: number }[] {\n    if (!words.length || segmentDuration <= 0) return [];\n\n    const segments = [];\n    let currentSegment: TranscriptWord[] = [];\n    let segmentStartTime = 0;\n    \n    if (words.length > 0) {\n        segmentStartTime = words[0].start;\n    }\n\n    for (const word of words) {\n        if (word.start >= segmentStartTime + segmentDuration) {\n            if (currentSegment.length > 0) {\n                const segmentText = currentSegment.map(w => w.text).join(' ').trim();\n                const segmentEndTime = currentSegment[currentSegment.length - 1].end;\n                segments.push({ text: segmentText, start: segmentStartTime, end: segmentEndTime });\n            }\n            currentSegment = [word];\n            segmentStartTime = word.start;\n        } else {\n            currentSegment.push(word);\n        }\n    }\n\n    if (currentSegment.length > 0) {\n        const segmentText = currentSegment.map(w => w.text).join(' ').trim();\n        const segmentEndTime = currentSegment[currentSegment.length - 1].end;\n        segments.push({ text: segmentText, start: segmentStartTime, end: segmentEndTime });\n    }\n\n    return segments;\n}\n\nfunction exportToSrt(text: string, words: TranscriptWord[], wordsPerSecond?: number): string | null {\n    if ((!words || words.length === 0)) return null;\n\n    let srtContent = '';\n    \n    if (wordsPerSecond && wordsPerSecond > 0) {\n        const segments = groupWordsIntoSegments(words, wordsPerSecond);\n        segments.forEach((segment, i) => {\n            srtContent += `${i + 1}\\n`;\n            srtContent += `${formatSrtTime(segment.start)} --> ${formatSrtTime(segment.end)}\\n`;\n            srtContent += `${segment.text}\\n\\n`;\n        });\n    } else {\n        words.forEach((word, i) => {\n            srtContent += `${i + 1}\\n`;\n            srtContent += `${formatSrtTime(word.start)} --> ${formatSrtTime(word.end)}\\n`;\n            srtContent += `${word.text}\\n\\n`;\n        });\n    }\n  \n    return srtContent;\n}\n  \nfunction exportToVtt(text: string, words: TranscriptWord[], wordsPerSecond?: number): string | null {\n    if (!words || words.length === 0) return null;\n\n    let vttContent = 'WEBVTT\\n\\n';\n    \n    if (wordsPerSecond && wordsPerSecond > 0) {\n        const segments = groupWordsIntoSegments(words, wordsPerSecond);\n        segments.forEach((segment, i) => {\n            vttContent += `${formatVttTime(segment.start)} --> ${formatVttTime(segment.end)}\\n`;\n            vttContent += `${segment.text}\\n\\n`;\n        });\n\n    } else {\n        words.forEach((word) => {\n            vttContent += `${formatVttTime(word.start)} --> ${formatVttTime(word.end)}\\n`;\n            vttContent += `${word.text}\\n\\n`;\n        });\n    }\n    \n    return vttContent;\n}\n  \nfunction exportToTxt(text: string): string {\n  return text;\n}\n\nfunction exportToJson(words: TranscriptWord[]): string | null {\n    if (words.length === 0) return null;\n    return JSON.stringify(words, null, 2);\n}\n  \nfunction exportToCsv(words: TranscriptWord[]): string | null {\n    if (words.length === 0) return null;\n    let csvContent = 'text,start,end\\n';\n    words.forEach(word => {\n        const text = `\"${word.text.replace(/\"/g, '\"\"')}\"`;\n        csvContent += `${text},${word.start},${word.end}\\n`;\n    });\n    return csvContent;\n}\n\nasync function exportToDocx(text: string): Promise<Blob> {\n    const doc = new Document({\n      sections: [{\n        properties: {},\n        children: text.split('\\n').map(line => \n            new Paragraph({\n                children: [new TextRun(line)]\n            })\n        ),\n      }],\n    });\n  \n    return await Packer.toBlob(doc);\n}\n\n\nfunction downloadFile(content: string | Blob, filename: string, mimeType: string): void {\n    const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n}\n\nexport async function exportTranscript(\n    text: string,\n    format: 'srt' | 'vtt' | 'txt' | 'json' | 'csv' | 'docx',\n    words: TranscriptWord[],\n    showToast: (options: { title: string; description: string; variant: 'destructive' }) => void,\n    wordsPerSecond?: number\n  ): Promise<void> {\n    if (!text.trim() && format !== 'json' && format !== 'csv' && format !== 'docx') {\n      showToast({\n        title: \"Export Failed\",\n        description: \"There is no text to export.\",\n        variant: \"destructive\",\n      });\n      return;\n    }\n    \n    let content: string | Blob | null = null;\n    let filename: string = 'transcript';\n    let mimeType: string = 'text/plain';\n\n    switch (format) {\n      case 'srt':\n        content = exportToSrt(text, words, wordsPerSecond);\n        filename += '.srt';\n        if (!content) {\n          showToast({\n            title: \"Export Failed\",\n            description: \"Word timings not available for SRT export. Try using the 'Words per second' setting.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n        break;\n      case 'vtt':\n          content = exportToVtt(text, words, wordsPerSecond);\n          filename += '.vtt';\n          mimeType = 'text/vtt';\n          if (!content) {\n            showToast({\n              title: \"Export Failed\",\n              description: \"Word timings not available for VTT export. Try using the 'Words per second' setting.\",\n              variant: \"destructive\",\n            });\n            return;\n          }\n          break;\n      case 'txt':\n        content = exportToTxt(text);\n        filename += '.txt';\n        break;\n      case 'json':\n        content = exportToJson(words);\n        filename += '.json';\n        mimeType = 'application/json';\n        if (!content) {\n            showToast({\n                title: \"Export Failed\",\n                description: \"No structured transcript available for JSON export.\",\n                variant: \"destructive\",\n            });\n            return;\n        }\n        break;\n      case 'csv':\n          content = exportToCsv(words);\n          filename += '.csv';\n          mimeType = 'text/csv';\n          if (!content) {\n              showToast({\n                  title: \"Export Failed\",\n                  description: \"No structured transcript available for CSV export.\",\n                  variant: \"destructive\",\n              });\n              return;\n          }\n          break;\n      case 'docx':\n        try {\n            content = await exportToDocx(text);\n            filename += '.docx';\n            mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';\n        } catch (error) {\n            console.error(\"Failed to export DOCX:\", error);\n            showToast({\n                title: \"Export Failed\",\n                description: \"Could not create DOCX file.\",\n                variant: \"destructive\",\n            });\n            return;\n        }\n        break;\n      default:\n        showToast({\n            title: \"Export Failed\",\n            description: \"Unsupported export format.\",\n            variant: \"destructive\",\n          });\n        return;\n    }\n\n    if (content) {\n        downloadFile(content, filename, mimeType);\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}